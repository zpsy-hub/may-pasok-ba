<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>May Pasok Ba?</title>
    <!-- External Libraries -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Favicon: rain emoji as SVG data URL -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ctext y='50%25' x='50%25' dominant-baseline='middle' text-anchor='middle' font-size='38'%3E%F0%9F%8C%A7%3C/text%3E%3C/svg%3E">

    <style>
        /* --- CSS Variables and Global Styles --- */
        :root {
            --primary: #007bff;
            --success: #28a745;
            --warning: #ffc107;
            --danger: #dc3545;
            --light-bg: #f8f9fa;
            --card-shadow: 0 4px 12px rgba(0,0,0,0.08);
            --text-primary: #212529;
            --text-secondary: #6c757d;
        }
        * { box-sizing: border-box; }
        html, body {
            font-family: 'Inter', sans-serif;
            background-color: #ffffff;
            color: var(--text-primary);
        }
        .main-container { max-width: 1200px; margin: 0 auto; padding: 3rem 2rem; }
        .lucide { width: 1em; height: 1em; vertical-align: -0.125em; }

        /* --- Header & LGU Selector --- */
        .header { text-align: center; margin-bottom: 2rem; }
        .brand { font-size: 2.8rem; font-weight: 800; margin: 0 0 0.25rem 0; color: var(--primary); }
        .subtitle { font-size: 1rem; color: var(--text-secondary); margin-bottom: 1.5rem; }
        .disclaimer { background: #eef5ff; padding: 1rem 1.5rem; border-radius: 12px; text-align: center; font-size: 0.95rem; color: #004a99; border: 1px solid #b3d1ff; line-height: 1.6; }
        .lgu-selector { margin-bottom: 2rem; display: flex; gap: 0.75rem; }
        .lgu-selector select { flex-grow: 1; padding: 0.75rem 1rem; border: 2px solid #e9ecef; border-radius: 12px; font-size: 1rem; font-weight: 600; background: white; cursor: pointer; }
        .btn-refresh { width: 48px; height: 48px; border-radius: 12px; background: rgba(0,123,255,0.1); border: 2px solid rgba(0,123,255,0.2); color: var(--primary); display: flex; align-items: center; justify-content: center; cursor: pointer; transition: transform 0.8s ease; }
        .btn-refresh.spinning { transform: rotate(360deg); }
        
        /* --- Dynamic Greeting --- */
        .greeting-header {
            text-align: center;
            margin-bottom: 2.5rem;
            font-size: 1.15rem;
            color: var(--text-secondary);
            line-height: 1.7;
        }
        .greeting-header strong {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* --- Prediction Card & Sections --- */
        .prediction-card { text-align: center; padding: 2.5rem 1.5rem; border-radius: 24px; margin-bottom: 2rem; box-shadow: 0 8px 24px rgba(0,0,0,0.12); transition: background 0.5s ease; }
        .prediction-card.bg-classes-expected { background: linear-gradient(135deg, #d4edda, #f8f9fa); }
        .prediction-card.bg-monitor { background: linear-gradient(135deg, #fff3cd, #f8f9fa); }
        .prediction-card.bg-suspend { background: linear-gradient(135deg, #f8d7da, #f8f9fa); }
        .recommendation-badge { display: inline-block; padding: 0.6rem 2rem; border-radius: 50px; font-size: 1.2rem; font-weight: 800; text-transform: uppercase; letter-spacing: 1.5px; }
        .recommendation-badge.classes-expected { background: #d4edda; color: #155724; }
        .recommendation-badge.monitor { background: #fff3cd; color: #856404; }
        .recommendation-badge.suspend { background: #f8d7da; color: #721c24; }
        .recommendation-context { font-size: 1.05rem; color: var(--text-secondary); margin: 0.75rem auto 1.5rem auto; max-width: 480px; line-height: 1.6; }
        .probability-value { font-size: 5rem; font-weight: 900; color: var(--text-primary); }
        .probability-label { font-size: 1.05rem; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 1.5px; display: block; margin-top: 0.5rem; }
        .weather-icon-large { font-size: 4rem; margin: 2rem 0 0 0; animation: float 3s ease-in-out infinite; }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-12px); } }
        .section-container { margin-bottom: 3rem; }
        .section-title { font-size: 1.3rem; font-weight: 700; color: var(--text-primary); margin-bottom: 1.5rem; text-align: center; text-transform: uppercase; letter-spacing: 1px; }
        .alert-box { display: flex; align-items: center; justify-content: center; gap: 0.75rem; padding: 1rem; border-radius: 12px; font-size: 0.95rem; font-weight: 600; line-height: 1.5; border-width: 1px; border-style: solid; margin-bottom: 0.5rem; }
        .alert-box.typhoon-direct { background: #f8d7da; color: #721c24; border-color: rgba(220, 53, 69, 0.3); }
        .alert-box.rainfall-red { background: #f8d7da; color: #721c24; border-color: rgba(220, 53, 69, 0.3); }
        .alert-box.rainfall-orange { background: #fff3cd; color: #856404; border-color: rgba(255, 193, 7, 0.3); }
        .alert-box.rainfall-yellow { background: #fff3cd; color: #856404; border-color: rgba(255, 193, 7, 0.3); }
        .alert-box.rainfall-info { background: #e7f3ff; color: #004085; border-color: rgba(0, 123, 255, 0.3); }
        .recommendation-reasons-card { background: white; border: 2px solid #e9ecef; border-radius: 16px; padding: 1.25rem; }
        .reason-item { display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.6rem; border-radius: 12px; font-size: 0.95rem; }
        .reason-item.typhoon-reason { background: #fff3cd; color: #856404; }
        .reason-item.model-reason { background: #e7f3ff; color: #004085; }

        /* --- Weather Grid & Hourly Forecast --- */
        .weather-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
        .weather-metric { background: white; padding: 1rem; border-radius: 16px; border: 2px solid #e9ecef; display: flex; align-items: center; gap: 1rem; }
        .metric-icon-wrapper { background-color: rgba(0,123,255,0.1); color: var(--primary); border-radius: 12px; width: 48px; height: 48px; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .metric-icon-wrapper .lucide { width: 24px; height: 24px; }
        .metric-content { text-align: left; }
        .metric-value-wrapper { display: flex; align-items: baseline; gap: 0.5rem; flex-wrap: wrap; }
        .metric-value { font-size: 1.4rem; font-weight: 700; color: var(--text-primary); }
        .metric-label { font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 0.25rem; }
        .metric-context { font-size: 0.8rem; font-weight: 500; color: var(--text-secondary); }
        .metric-context.danger { color: var(--danger); }
        .metric-context.warning { color: var(--warning); }
        .hourly-list-item { display: grid; grid-template-columns: 80px 50px 1fr 1fr 90px; align-items: center; padding: 0.75rem 0.5rem; border-bottom: 1px solid #e9ecef; font-size: 0.9rem; }
        .hourly-list-item:last-child { border-bottom: none; }
        .hourly-list-item .time { font-weight: 600; }
        .hourly-list-item .icon { font-size: 1.8rem; text-align: center; }
        .hourly-list-item .temp { font-weight: 700; font-size: 1.1rem; }
        .hourly-list-item .realfeel { color: var(--text-secondary); }
        .hourly-list-item .precip-details { display: flex; flex-direction: column; align-items: flex-end; gap: 0.2rem; }
        .hourly-list-item .precip { color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 0.3rem; }
        .hourly-list-item .precip .lucide { width: 14px; height: 14px; }
        .hourly-list-item .rainfall { font-size: 0.8rem; color: var(--text-secondary); }

        /* --- Floating Buttons & Modals --- */
        .floating-btn { 
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 0.75rem 1.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 1000;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            position: fixed;
            right: 20px;
            text-decoration: none;
            color: var(--primary);
            font-family: 'Inter', sans-serif;
        }
        .floating-btn:hover { 
            transform: translateY(-2px);
            border-color: var(--primary);
            background: #f8f9fa;
        }
        .feedback-btn { bottom: 20px; }
        .learn-more-btn { bottom: 80px; }
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center; }
        .modal-overlay.active { display: flex; }
        .modal-content { background: white; border-radius: 16px; padding: 2rem; max-width: 500px; width: 90%; max-height: 90vh; overflow-y: auto; position: relative; animation: slideUp 0.3s ease; }
        @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-close { position: absolute; top: 1rem; right: 1rem; background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-secondary); }
        .modal-content h3 { margin: 0 0 1.5rem 0; font-size: 1.5rem; font-weight: 700; }
        
        /* --- Rewritten Feedback Modal Styles --- */
        .feedback-question { margin-bottom: 1.5rem; }
        .feedback-question label { display: block; font-weight: 600; margin-bottom: 0.75rem; }
        .rating-options { display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.25rem; }
        .rating-option { flex: 1; min-width: 40px; padding: 0.75rem 0.5rem; border: 2px solid #e9ecef; border-radius: 12px; text-align: center; cursor: pointer; transition: all 0.2s; font-weight: 600; }
        .rating-option:hover { border-color: var(--primary); background: rgba(0,123,255,0.05); }
        .rating-option.selected { border-color: var(--primary); background: var(--primary); color: white; }
        .rating-labels { display: flex; justify-content: space-between; font-size: 0.8rem; color: var(--text-secondary); padding: 0 0.25rem; }
        .feedback-textarea { width: 100%; padding: 0.75rem 1rem; border: 2px solid #e9ecef; border-radius: 12px; font-size: 1rem; font-family: 'Inter', sans-serif; resize: vertical; }
        .feedback-textarea:focus { outline: none; border-color: var(--primary); }
        .btn-submit { background-color: var(--primary); color: white; width: 100%; border: none; padding: 0.8rem 1rem; font-size: 1rem; font-weight: 600; border-radius: 12px; cursor: pointer; transition: background-color 0.3s; margin-top: 1rem; }
        .btn-submit:hover { background-color: #0056b3; }
        .btn-submit:disabled { background-color: #a0caff; cursor: not-allowed; }
        .feedback-success-icon .lucide { color: var(--success); width: 4rem; height: 4rem; stroke-width: 1.5; }

        /* --- Misc --- */
        .acknowledgements-card { background-color: var(--light-bg); padding: 1.5rem; border-radius: 16px; }
        .acknowledgements-card h3 { font-weight: 700; font-size: 1.2rem; margin-top: 1rem; margin-bottom: 1rem; }
        .acknowledgements-card p, .acknowledgements-card li { color: var(--text-secondary); font-size: 0.95rem; }
        .acknowledgements-card ul { list-style: none; padding-left: 0; }
        .acknowledgements-card li { background-color: #fff; padding: 1rem; border-radius: 12px; margin-bottom: 0.75rem; display: flex; align-items: flex-start; gap: 1rem; border: 1px solid #e9ecef;}
        .acknowledgements-card a { color: var(--primary); font-weight: 600; }
        .last-updated { text-align: center; font-size: 0.85rem; color: var(--text-secondary); margin-top: 2rem; }
        .loading-spinner { text-align: center; padding: 4rem; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid var(--primary); border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 1rem; }

        /* --- Key Hours Summary --- */
        .key-hours { display: grid; grid-template-columns: repeat(3, 1fr); gap: 1.5rem; margin: 2rem 0; }
        .hour-alert { padding: 1.75rem; border-radius: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        .hour-alert.safe { background: linear-gradient(135deg, #e8f5e9, #f1f8f4); color: #2e7d32; }
        .hour-alert.caution { background: linear-gradient(135deg, #fff9e6, #fffbf0); color: #d68400; }
        .hour-alert.warning { background: linear-gradient(135deg, #fce4e4, #fef0f0); color: #c62828; }
        .hour-alert-title { font-weight: 600; font-size: 1.1rem; margin-bottom: 0.75rem; display: flex; align-items: center; gap: 0.5rem; }
        .hour-alert-detail { font-size: 1rem; margin: 0.25rem 0; line-height: 1.6; }
        .rain-indicator { display: inline-block; width: 80px; height: 6px; background: #e9ecef; border-radius: 3px; overflow: hidden; vertical-align: middle; margin: 0 6px; }
        .rain-fill { height: 100%; background: #007bff; transition: width 0.3s ease; }

        /* --- Rain Chart Styles --- */
        .chart-container { background: white; border: 1px solid #e9ecef; border-radius: 16px; padding: 2rem; position: relative; }
        .chart-header { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-bottom: 1.5rem; }
        .hour-header { text-align: center; padding: 0.75rem 0.5rem; border-radius: 8px; background: white; border: 1px solid #e9ecef; cursor: pointer; transition: all 0.2s ease; position: relative; }
        .hour-header:hover { background: #f8f9fa; border-color: #dee2e6; transform: translateY(-2px); }
        .hour-header.active { background: #e7f3ff; color: #004085; border-color: rgba(0, 123, 255, 0.3); }
        .header-icon { font-size: 2rem; margin-bottom: 0.25rem; }
        .header-temp { font-size: 0.85rem; font-weight: 600; color: #6c757d; }
        .hour-header.active .header-temp { color: #004085; }
        .chart-body { position: relative; height: 240px; margin: 2rem 0; }
        .bars-container { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; height: 100%; align-items: flex-end; }
        .rainfall-column { position: relative; display: flex; flex-direction: column; justify-content: flex-end; cursor: pointer; transition: all 0.3s ease; }
        .rainfall-column:hover { transform: translateY(-4px); }
        .rainfall-column:hover .rain-bar-fill { box-shadow: 0 4px 12px rgba(0, 123, 255, 0.15); }
        .rainfall-column.active { transform: translateY(-4px); }
        .rainfall-column.active .rain-bar-fill { box-shadow: 0 4px 12px rgba(0, 123, 255, 0.25); }
        .rain-bar-fill { width: 100%; background: linear-gradient(to top, #007bff, #4a9eff); border-radius: 8px 8px 0 0; transition: all 0.3s ease; position: relative; }
        .rain-amount { position: absolute; top: -45px; left: 50%; transform: translateX(-50%); font-size: 0.85rem; font-weight: 700; color: #007bff; white-space: nowrap; }
        .rain-probability { position: absolute; top: -26px; left: 50%; transform: translateX(-50%); font-size: 0.75rem; font-weight: 400; color: #90caf9; white-space: nowrap; }
        .chart-footer { display: grid; grid-template-columns: repeat(12, 1fr); gap: 12px; margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid #e9ecef; }
        .hour-time { text-align: center; font-weight: 600; font-size: 0.9rem; color: #495057; }
        .rain-tooltip { position: fixed; background: white; border: 1px solid #dee2e6; border-radius: 16px; padding: 1rem; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 280px; display: none; pointer-events: none; }
        .rain-tooltip.show { display: block; }
        .tooltip-header { font-weight: 600; font-size: 1rem; margin-bottom: 0.75rem; color: #212529; display: flex; align-items: center; gap: 0.5rem; }
        .tooltip-row { display: flex; justify-content: space-between; padding: 0.4rem 0; border-bottom: 1px solid #f1f3f5; }
        .tooltip-row:last-child { border-bottom: none; }
        .tooltip-label { font-size: 0.85rem; color: #6c757d; }
        .tooltip-value { font-weight: 600; font-size: 0.85rem; color: #212529; }
        .tooltip-advisory { margin-top: 0.75rem; padding: 0.75rem; background: #fff3cd; border-left: 3px solid #ffc107; border-radius: 8px; font-size: 0.85rem; line-height: 1.5; color: #856404; }
        .tooltip-advisory.safe { background: #d4edda; border-color: #28a745; color: #155724; }
        .tooltip-advisory.warning { background: #f8d7da; border-color: #dc3545; color: #721c24; }

        @media (max-width: 768px) {
            .key-hours { grid-template-columns: 1fr; }
            .chart-header, .bars-container, .chart-footer { grid-template-columns: repeat(6, 1fr); }
            .hour-header { padding: 0.4rem 0.2rem; }
            .header-icon { font-size: 1.2rem; }
            .header-temp { font-size: 0.7rem; }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- Header -->
        <header class="header">
            <h1 class="brand">May Pasok Ba?</h1>
            <p class="subtitle">AI-Powered Decision Support for Class Suspensions in Metro Manila</p>
            <div class="disclaimer"><strong>This is a weather-based forecast, not an announcement.</strong><br>
            Only your LGU can officially suspend classes. Always check official channels.</div>
        </header>

        <!-- LGU Selector -->
        <div class="lgu-selector">
            <select id="lguSelect" aria-label="Select a Local Government Unit"></select>
            <button class="btn-refresh" id="refreshBtn" aria-label="Refresh Data"><i data-lucide="refresh-cw"></i></button>
        </div>

        <!-- Selected LGU Heading -->
        <div id="selectedLguHeading" style="text-align: center; margin: 1.5rem 0; display: none;">
            <h2 style="font-size: 2rem; font-weight: 700; color: var(--text-primary); margin: 0;">
                <span id="selectedLguName"></span>
            </h2>
        </div>

        <!-- Main Content Area -->
        <main id="appContent">
            <div id="loading" class="loading-spinner">
                <div class="spinner"></div>
                <p>Analyzing the latest weather data...</p>
            </div>

            <div id="mainContent" style="display: none;">
                <!-- DYNAMIC GREETING WILL BE INSERTED HERE -->
                <div id="dynamicGreeting" class="greeting-header"></div>

                <!-- Typhoon and Rainfall Alerts (now integrated into prediction card) -->
                <!-- <div id="typhoonAlert" class="section-container" style="display: none; margin-bottom: 1rem;"></div>
                <div id="rainfallAlert" class="section-container" style="display: none; margin-bottom: 1rem;"></div> -->

                <!-- Prediction Card -->
                <div id="predictionCard" class="prediction-card"></div>
                
                <!-- Key Hours and Rain Chart (shown for individual LGUs) -->
                <div id="keyHoursSection" class="section-container" style="display: none; margin-top: 2rem;">
                    <h6 class="section-title">Key Hours: Quick Risk Assessment</h6>
                    <div class="key-hours" id="keyHoursGrid"></div>
                </div>
                <div id="rainChartSection" class="section-container" style="display: none;">
                    <h6 class="section-title">Hourly Rain Forecast & Temperature</h6>
                    <div class="chart-container">
                        <div class="chart-header" id="rainChartHeader"></div>
                        <div class="chart-body">
                            <div class="bars-container" id="rainBarsContainer"></div>
                        </div>
                        <div class="chart-footer" id="rainChartFooter"></div>
                    </div>
                    <div class="rain-tooltip" id="rainTooltip"></div>
                </div>

                <!-- Recommendation Reasons -->
                <div id="recommendationReasonsContainer" class="section-container" style="display: none; margin-bottom:0;">
                    <h6 class="section-title">Key Decision Factors</h6>
                    <div class="recommendation-reasons-card" id="reasonsList"></div>
                </div>
                
                <!-- Tomorrow's Weather Summary (Key Metrics) -->
                <div id="weatherMetricsSection" class="section-container" style="display: none;">
                    <h6 class="section-title">Tomorrow's Weather Summary</h6>
                    <div class="weather-grid" id="weatherMetricsGrid"></div>
                </div>
                
                <!-- About and Acknowledgements -->
                <div class="section-container">
                    <div class="acknowledgements-card">
                        <h3>About This Project</h3>
                        <p>"May Pasok Ba?" is an AI-powered capstone project designed to forecast the likelihood of class suspensions in Metro Manila using meteorological data, typhoon warnings, and historical records.</p>
                        <h3>Data Sources & APIs</h3>
                        <ul>
                            <li><i data-lucide="cloud-sun"></i><div><strong>Weather Forecast Data:</strong> <a href="https://open-meteo.com/" target="_blank" rel="noopener noreferrer">Open-Meteo API</a></div></li>
                            <li><i data-lucide="calendar"></i><div><strong>Philippine Holiday Information:</strong> <a href="https://date.nager.at/" target="_blank" rel="noopener noreferrer">Nager.Date API</a></div></li>
                            <li><i data-lucide="wind"></i><div><strong>Typhoon Data Parsing:</strong> Interpreted via the open-source <a href="https://github.com/chlodss/pagasa-parser" target="_blank" rel="noopener noreferrer">PAGASA-Parser</a> library by Chlod Aidan Alejandro.</div></li>
                        </ul>
                    </div>
                </div>
                <footer class="last-updated" id="lastUpdated"></footer>
            </div>
        </main>
    </div>

    <!-- Floating Action Buttons -->
    <a href="prediction-logs.html" class="floating-btn learn-more-btn"><i data-lucide="bar-chart-3"></i> Prediction Logs</a>
    <button class="floating-btn feedback-btn" id="openFeedbackBtn"><i data-lucide="message-square-plus"></i> Send Feedback</button>

    <!-- Feedback Modal -->
    <div class="modal-overlay" id="feedbackModal">
        <div class="modal-content">
            <button class="modal-close" id="closeFeedbackBtn" aria-label="Close modal">&times;</button>
            
            <form id="feedbackForm" action="https://api.web3forms.com/submit" method="POST">
                <!-- REQUIRED WEB3FORMS INPUTS -->
                <input type="hidden" name="access_key" value="a829bc24-af6b-4f40-9558-e453e34d1dee">
                <input type="hidden" name="subject" value="New Feedback from MayPasokBa?">
                <input type="checkbox" name="botcheck" class="hidden" style="display: none;">

                <!-- HIDDEN INPUTS TO STORE RATING VALUES FOR SUBMISSION -->
                <input type="hidden" name="helpfulness" id="helpfulnessInput" value="">
                <input type="hidden" name="trust" id="trustInput" value="">
                <input type="hidden" name="clarity" id="clarityInput" value="">

                <h3>We'd Love Your Feedback!</h3>
                <div class="feedback-question">
                    <label>1. How helpful is this prediction tool?</label>
                    <div class="rating-options" id="helpfulnessRating">
                        <div class="rating-option" onclick="selectRating('helpfulness', 1)">1</div>
                        <div class="rating-option" onclick="selectRating('helpfulness', 2)">2</div>
                        <div class="rating-option" onclick="selectRating('helpfulness', 3)">3</div>
                        <div class="rating-option" onclick="selectRating('helpfulness', 4)">4</div>
                        <div class="rating-option" onclick="selectRating('helpfulness', 5)">5</div>
                    </div>
                    <div class="rating-labels"><small>Not helpful</small><small>Very helpful</small></div>
                </div>
                <div class="feedback-question">
                    <label>2. How much do you trust these predictions?</label>
                    <div class="rating-options" id="trustRating">
                        <div class="rating-option" onclick="selectRating('trust', 1)">1</div>
                        <div class="rating-option" onclick="selectRating('trust', 2)">2</div>
                        <div class="rating-option" onclick="selectRating('trust', 3)">3</div>
                        <div class="rating-option" onclick="selectRating('trust', 4)">4</div>
                        <div class="rating-option" onclick="selectRating('trust', 5)">5</div>
                    </div>
                     <div class="rating-labels"><small>Low trust</small><small>High trust</small></div>
                </div>
                 <div class="feedback-question">
                    <label>3. How clear was the information presented?</label>
                    <div class="rating-options" id="clarityRating">
                        <div class="rating-option" onclick="selectRating('clarity', 1)">1</div>
                        <div class="rating-option" onclick="selectRating('clarity', 2)">2</div>
                        <div class="rating-option" onclick="selectRating('clarity', 3)">3</div>
                        <div class="rating-option" onclick="selectRating('clarity', 4)">4</div>
                        <div class="rating-option" onclick="selectRating('clarity', 5)">5</div>
                    </div>
                     <div class="rating-labels"><small>Confusing</small><small>Very clear</small></div>
                </div>
                <div class="feedback-question">
                     <label for="feedbackComments">4. Any other comments or suggestions? (Optional)</label>
                     <textarea id="feedbackComments" name="comments" class="feedback-textarea" rows="4" placeholder="Tell us what you think..."></textarea>
                </div>
                <button type="submit" id="submitFeedbackBtn" class="btn-submit">Submit Feedback</button>
            </form>

            <div id="feedbackSuccess" style="display: none; text-align: center;">
                <div class="feedback-success-icon"><i data-lucide="check-circle"></i></div>
                <h4>Thank You!</h4><p>Your feedback has been submitted.</p>
            </div>
        </div>
    </div>

    <script>
    (() => {
        'use strict';

        // --- 1. CONSTANTS & STATE MANAGEMENT ---
        const CACHE_KEYS = {
            PREDICTIONS: 'may_pasok_ba_cache',
            HOURLY_WEATHER: 'hourly_data_v4_',
            HOLIDAYS: 'ph_holidays_cache'
        };
        const CACHE_DURATION = {
            PREDICTIONS: 3600000, // 1 hour
            HOURLY_WEATHER: 900000, // 15 minutes
            HOLIDAYS: 86400000 // 24 hours
        };
        const LGU_COORDS = { "Manila": { lat: 14.5995, lon: 120.9842 }, "Quezon City": { lat: 14.6508, lon: 121.0487 }, "Caloocan": { lat: 14.6538, lon: 120.9934 }, "Makati": { lat: 14.5547, lon: 121.0244 }, "Pasig": { lat: 14.5768, lon: 121.0854 }, "Taguig": { lat: 14.5176, lon: 121.0509 }, "Pasay": { lat: 14.5378, lon: 121.0016 }, "Mandaluyong": { lat: 14.5804, lon: 121.0336 }, "Parañaque": { lat: 14.4793, lon: 121.0189 }, "Valenzuela": { lat: 14.7040, lon: 120.9844 }, "Las Piñas": { lat: 14.4449, lon: 120.9934 }, "Malabon": { lat: 14.6565, lon: 120.9634 }, "Marikina": { lat: 14.6465, lon: 121.1030 }, "Muntinlupa": { lat: 14.4084, lon: 121.0416 }, "Navotas": { lat: 14.6644, lon: 120.9392 }, "San Juan": { lat: 14.6019, lon: 121.0332 }, "Pateros": { lat: 14.5422, lon: 121.0664 } };
        
        const appState = {
            predictionData: null,
            holidays: null,
            selectedLGU: 'metro_manila',
            feedback: { helpfulness: null, trust: null, clarity: null }
        };

        const dom = {
            loading: document.getElementById('loading'),
            mainContent: document.getElementById('mainContent'),
            dynamicGreeting: document.getElementById('dynamicGreeting'),
            lguSelect: document.getElementById('lguSelect'),
            refreshBtn: document.getElementById('refreshBtn'),
            selectedLguHeading: document.getElementById('selectedLguHeading'),
            selectedLguName: document.getElementById('selectedLguName'),
            predictionCard: document.getElementById('predictionCard'),
            typhoonAlert: document.getElementById('typhoonAlert'),
            rainfallAlert: document.getElementById('rainfallAlert'),
            reasonsContainer: document.getElementById('recommendationReasonsContainer'),
            reasonsList: document.getElementById('reasonsList'),
            weatherMetricsSection: document.getElementById('weatherMetricsSection'),
            weatherMetricsGrid: document.getElementById('weatherMetricsGrid'),
            hourlyForecastSection: document.getElementById('hourlyForecastSection'),
            hourlyListView: document.getElementById('hourlyListView'),
            lastUpdated: document.getElementById('lastUpdated'),
            feedbackModal: document.getElementById('feedbackModal'),
            feedbackForm: document.getElementById('feedbackForm'),
            feedbackSuccess: document.getElementById('feedbackSuccess')
        };
        
        // --- 2. INITIALIZATION & EVENT LISTENERS ---
        document.addEventListener('DOMContentLoaded', initialize);

        function initialize() {
            lucide.createIcons();
            addEventListeners();
            fetchHolidays(); // Fetch holiday data in the background
            loadInitialData();
        }

        function addEventListeners() {
            dom.lguSelect.addEventListener('change', (e) => handleLGUChange(e.target.value));
            dom.refreshBtn.addEventListener('click', handleRefresh);
            document.getElementById('openFeedbackBtn').addEventListener('click', openFeedbackModal);
            document.getElementById('closeFeedbackBtn').addEventListener('click', closeFeedbackModal);
            dom.feedbackForm.addEventListener('submit', handleFeedbackSubmit);
            dom.feedbackModal.addEventListener('click', (e) => { if (e.target === dom.feedbackModal) closeFeedbackModal(); });
        }

        async function loadInitialData() {
            const cachedData = getCache(CACHE_KEYS.PREDICTIONS);
            if (cachedData) {
                appState.predictionData = cachedData;
                render();
                fetchPredictions(true);
            } else {
                fetchPredictions(false);
            }
        }

        // --- 3. DATA FETCHING & CACHING ---
        async function fetchPredictions(isBackgroundRefresh = false) {
            if (!isBackgroundRefresh) {
                dom.loading.style.display = 'block';
                dom.mainContent.style.display = 'none';
            }
            dom.refreshBtn.classList.add('spinning');

            try {
                // Fetch from latest.json (updated by GitHub Actions every 30 minutes)
                console.log('📡 Fetching predictions from latest.json...');
                const response = await fetch(`predictions/latest.json?t=${new Date().getTime()}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const newData = await response.json();
                const dataTimestamp = new Date(newData.generated_at || newData.metadata?.timestamp);
                const dataAge = (Date.now() - dataTimestamp.getTime()) / (1000 * 60); // minutes
                
                console.log(`✅ Loaded predictions (${dataAge.toFixed(0)} minutes old)`);
                
                // Show warning if data is stale (older than 2 hours)
                if (dataAge > 120) {
                    console.warn(`⚠️  Data is ${(dataAge/60).toFixed(1)} hours old`);
                }

                if (JSON.stringify(newData) !== JSON.stringify(appState.predictionData)) {
                    appState.predictionData = newData;
                    setCache(CACHE_KEYS.PREDICTIONS, newData, CACHE_DURATION.PREDICTIONS);
                    render();
                }
            } catch (error) {
                console.error('❌ Failed to fetch predictions:', error);
                
                if (!isBackgroundRefresh) {
                    showError('Unable to load predictions. Please check your internet connection and try again.');
                }
            } finally {
                if (!isBackgroundRefresh) {
                    dom.loading.style.display = 'none';
                    dom.mainContent.style.display = 'block';
                }
                setTimeout(() => dom.refreshBtn.classList.remove('spinning'), 500);
            }
        }
        
        async function fetchHolidays() {
            let holidays = getCache(CACHE_KEYS.HOLIDAYS);
            if (!holidays) {
                try {
                    const year = new Date().getFullYear();
                    const response = await fetch(`https://date.nager.at/api/v3/PublicHolidays/${year}/PH`);
                    if (!response.ok) throw new Error('Holiday API failed');
                    holidays = await response.json();
                    setCache(CACHE_KEYS.HOLIDAYS, holidays, CACHE_DURATION.HOLIDAYS);
                } catch (error) {
                    console.error("Could not fetch holiday data:", error);
                    holidays = []; // Set to empty array on failure
                }
            }
            appState.holidays = holidays;
        }

        // --- 4. MAIN RENDER LOGIC ---
        function render() {
            if (!appState.predictionData) return;
            dom.loading.style.display = 'none';
            dom.mainContent.style.display = 'block';
            // Greeting and date
            renderGreeting();
            // LGU selector
            renderLGUDropdown();
            // Update LGU heading
            updateLGUHeading();

            // Render the main content (prediction card / details)
            if (appState.selectedLGU === 'metro_manila') renderMetroManilaSummary();
            else renderLGUDetails(appState.selectedLGU);

            // Alerts now integrated into prediction card
            // renderTyphoonAlert();
            // renderRainfallAlert();
            lucide.createIcons();
        }

        // --- 5. UI RENDERING SUB-FUNCTIONS ---
        function updateLGUHeading() {
            // City name now shown inside the card, so always hide the separate heading
            dom.selectedLguHeading.style.display = 'none';
        }
        function renderGreeting() {
            const now = new Date();
            const hour = now.getHours();
            const day = now.getDay();
            
            let timeGreeting;
            if (hour < 12) timeGreeting = "Good morning!";
            else if (hour < 18) timeGreeting = "Good afternoon!";
            else timeGreeting = "Good evening!";

            let specialGreeting = "";
            const todayStr = now.toISOString().split('T')[0];
            const holidayToday = appState.holidays?.find(h => h.date === todayStr);

            if (holidayToday) {
                specialGreeting = ` Happy <strong>${holidayToday.localName}</strong>!`;
            } else if (day === 0 || day === 6) { // Sunday or Saturday
                specialGreeting = " Happy weekend!";
            }

            const tomorrow = new Date(now);
            tomorrow.setDate(now.getDate() + 1);
            const tomorrowFormatted = tomorrow.toLocaleDateString('en-US', {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            });

            // Build greeting with last updated timestamp
            let lastUpdatedText = '';
            try {
                const timestamp = new Date(appState.predictionData.metadata.timestamp);
                lastUpdatedText = `<div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 0.75rem; font-weight: 500;">
                    <i data-lucide="clock" style="width: 14px; height: 14px; vertical-align: middle;"></i> 
                    Last updated: ${timestamp.toLocaleString('en-US',{month:'short',day:'numeric',hour:'numeric',minute:'2-digit',hour12:true})}
                </div>`;
            } catch (e) {
                // fallback - no timestamp
            }

            dom.dynamicGreeting.innerHTML = `${timeGreeting}${specialGreeting}<br>Here is the recommendation for tomorrow, <strong>${tomorrowFormatted}</strong>.${lastUpdatedText}`;
            
            // Re-initialize Lucide icons for the newly added clock icon
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        function renderLGUDropdown() {
            const currentVal = dom.lguSelect.value;
            dom.lguSelect.innerHTML = '<option value="metro_manila">Metro Manila Overview</option>';
            
            // Helper function to normalize tier names
            function normalizeTier(prediction) {
                const tier = prediction.risk_tier?.tier || prediction.tier;
                if (tier === 'suspension') return 'RED';
                if (tier === 'alert') return 'ORANGE';
                if (tier === 'normal') return 'GREEN';
                return tier?.toUpperCase() || 'GREEN';
            }
            
            // Some prediction objects may not include a `status` field (legacy). Treat missing status as success.
            const predictions = appState.predictionData.predictions
                .filter(p => (!('status' in p) || p.status === 'success'))
                .sort((a, b) => b.suspension_probability - a.suspension_probability);
            
            predictions.forEach(p => {
                const option = document.createElement('option');
                option.value = p.lgu;
                
                // Get tier and corresponding icon
                const tier = normalizeTier(p);
                let tierIcon = '';
                if (tier === 'RED') {
                    tierIcon = '🔴'; // Red circle for high risk
                } else if (tier === 'ORANGE') {
                    tierIcon = '🟠'; // Orange circle for medium risk
                } else {
                    tierIcon = '🟢'; // Green circle for low risk
                }
                
                option.textContent = `${tierIcon} ${p.lgu}`;
                dom.lguSelect.appendChild(option);
            });
            dom.lguSelect.value = currentVal && dom.lguSelect.querySelector(`option[value="${currentVal}"]`) ? currentVal : appState.selectedLGU;
        }

        function renderMetroManilaSummary() {
            console.log('renderMetroManilaSummary called');
            if (dom.hourlyForecastSection) dom.hourlyForecastSection.style.display = 'none';
            if (dom.reasonsContainer) dom.reasonsContainer.style.display = 'none';
            
            // Hide hourly charts for Metro Manila overview
            const keyHoursSection = document.getElementById('keyHoursSection');
            const rainChartSection = document.getElementById('rainChartSection');
            if (keyHoursSection) keyHoursSection.style.display = 'none';
            if (rainChartSection) rainChartSection.style.display = 'none';
            
            // Include legacy predictions without `status` as successes
            const predictions = appState.predictionData.predictions.filter(p => (!('status' in p) || p.status === 'success'));
            console.log('Predictions count:', predictions.length);
            if (predictions.length === 0) return;
            
            // Implement hybrid Metro Manila logic
            const metroOverview = getMetroOverviewHybrid(predictions);
            
            // Render the prediction card with hybrid logic
            renderMetroManilaPredictionCard(metroOverview);
            
            // Don't show weather metrics for Metro Manila overview
            // renderWeatherMetrics(predictions);
        }

        function getMetroOverviewHybrid(predictions) {
            // Helper function to normalize tier names (support both old and new formats)
            function normalizeTier(prediction) {
                const tier = prediction.risk_tier?.tier || prediction.tier;
                // Map old field names to new ones
                if (tier === 'suspension') return 'RED';
                if (tier === 'alert') return 'ORANGE';
                if (tier === 'normal') return 'GREEN';
                // Return as-is if already normalized
                return tier?.toUpperCase() || 'GREEN';
            }
            
            // Count tiers (support both risk_tier and tier fields, and old/new naming)
            const tierCounts = {
                'RED': predictions.filter(p => normalizeTier(p) === 'RED').length,
                'ORANGE': predictions.filter(p => normalizeTier(p) === 'ORANGE').length,
                'GREEN': predictions.filter(p => normalizeTier(p) === 'GREEN').length
            };
            
            const total = predictions.length;
            const significantMinority = 4; // 20% threshold
            
            // Get LGU names by tier
            const redLgus = predictions.filter(p => normalizeTier(p) === 'RED').map(p => p.lgu);
            const orangeLgus = predictions.filter(p => normalizeTier(p) === 'ORANGE').map(p => p.lgu);
            const greenLgus = predictions.filter(p => normalizeTier(p) === 'GREEN').map(p => p.lgu);
            
            // Determine primary status (highest alert wins)
            let primaryColor, primaryIcon, title, icon, message, exception;
            
            if (tierCounts.RED > 0) {
                primaryColor = 'RED';
                primaryIcon = '🔴';
                
                if (tierCounts.RED === total) {
                    // All RED
                    title = "METRO-WIDE EMERGENCY";
                    icon = "⛔⛔⛔";
                    message = `ALL ${total} LGUs UNDER HIGH RISK`;
                    exception = null;
                } else if (tierCounts.RED >= 9) {
                    // Majority RED
                    title = "WIDESPREAD HIGH RISK";
                    icon = "⛔";
                    message = "Severe weather affecting most of NCR";
                    const safeCount = tierCounts.GREEN + tierCounts.ORANGE;
                    exception = {
                        type: 'LESS_AFFECTED',
                        count: safeCount,
                        message: `${safeCount} LGUs less affected`
                    };
                } else {
                    // Localized RED
                    title = "LOCALIZED HIGH RISK";
                    icon = "⛔";
                    message = "Severe weather affecting specific areas";
                    const safeCount = tierCounts.GREEN;
                    exception = {
                        type: 'MOSTLY_SAFE',
                        count: safeCount + tierCounts.ORANGE,
                        message: `Most LGUs (${safeCount} safe, ${tierCounts.ORANGE} monitoring) remain normal`,
                        highRiskAreas: getGeographicCluster(redLgus)
                    };
                }
            } else if (tierCounts.ORANGE > 0) {
                primaryColor = 'ORANGE';
                primaryIcon = '🟠';
                
                if (tierCounts.ORANGE === total) {
                    // All ORANGE
                    title = "WIDESPREAD ALERT";
                    icon = "⚠️";
                    message = `ALL ${total} LGUs UNDER WEATHER ALERT`;
                    exception = null;
                } else if (tierCounts.ORANGE >= 9) {
                    // Majority ORANGE
                    title = "WIDESPREAD ALERT";
                    icon = "⚠️";
                    message = "Most NCR LGUs under weather alert";
                    exception = tierCounts.GREEN > 0 ? {
                        type: 'NORMAL_AREAS',
                        count: tierCounts.GREEN,
                        message: `${tierCounts.GREEN} LGUs remain normal`
                    } : null;
                } else {
                    // Mixed ORANGE
                    title = "REGIONAL ALERT";
                    icon = "🟠";
                    message = "Weather affecting parts of NCR";
                    exception = tierCounts.GREEN > 0 ? {
                        type: 'MOSTLY_NORMAL',
                        count: tierCounts.GREEN,
                        message: `Most LGUs normal (${tierCounts.GREEN} safe)`
                    } : null;
                }
            } else {
                // All GREEN
                primaryColor = 'GREEN';
                primaryIcon = '🟢';
                title = "NORMAL CONDITIONS";
                icon = "🟢";
                message = `All ${total} LGUs report low risk`;
                exception = null;
            }
            
            return {
                title,
                icon,
                primaryColor,
                primaryIcon,
                message,
                exception,
                tierCounts,
                total
            };
        }

        function getGeographicCluster(lguList) {
            const zones = {
                'Northern': ['Valenzuela', 'Malabon', 'Navotas', 'Caloocan'],
                'Eastern': ['Marikina', 'Pasig', 'San Juan'],
                'Southern': ['Parañaque', 'Las Piñas', 'Muntinlupa'],
                'Central': ['Manila', 'Makati', 'Mandaluyong', 'Quezon City'],
                'Western': ['Taguig', 'Pateros', 'Pasay']
            };
            
            for (const [zone, lgus] of Object.entries(zones)) {
                if (lguList.some(lgu => lgus.includes(lgu))) {
                    return `${zone} Metro Manila`;
                }
            }
            return "Multiple areas";
        }

        function renderMetroManilaPredictionCard(overview) {
            const { title, icon, primaryColor, message, exception, tierCounts, total } = overview;
            
            const recMap = {
                'RED': { className: 'suspend', emoji: '🔴' },
                'ORANGE': { className: 'monitor', emoji: '🟠' },
                'GREEN': { className: 'classes-expected', emoji: '🟢' }
            };
            
            const rec = recMap[primaryColor];
            
            dom.predictionCard.className = `prediction-card bg-${rec.className}`;
            
            // Build distribution text
            const distributionHtml = `
                <div style="margin: 1.5rem 0; font-size: 0.95rem; color: var(--text-secondary);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">📍 Risk Distribution:</div>
                    <div style="display: flex; justify-content: center; gap: 1rem; flex-wrap: wrap;">
                        <span>🔴 High Risk: ${tierCounts.RED} LGUs (${Math.round(tierCounts.RED*100/total)}%)</span>
                        <span>🟠 Moderate Risk: ${tierCounts.ORANGE} LGUs (${Math.round(tierCounts.ORANGE*100/total)}%)</span>
                        <span>🟢 Low Risk: ${tierCounts.GREEN} LGUs (${Math.round(tierCounts.GREEN*100/total)}%)</span>
                    </div>
                </div>
            `;
            
            // Build exception message if exists
            let exceptionHtml = '';
            if (exception) {
                exceptionHtml = `
                    <div style="margin-top: 1.5rem; padding: 1rem 1.5rem; background: rgba(0,0,0,0.05); border-radius: 12px; font-size: 0.9rem; line-height: 1.6;">
                        <div style="font-weight: 600; margin-bottom: 0.25rem;">
                            ${exception.type === 'ESCALATION' ? '⚠️ ALERT' : 'ℹ️ EXCEPTION'}:
                        </div>
                        <div>${exception.message}</div>
                        ${exception.highRiskAreas ? `<div style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-secondary);">High-risk areas: ${exception.highRiskAreas}</div>` : ''}
                    </div>
                `;
            }
            
            dom.predictionCard.innerHTML = `
                <h2 style="font-size: 2rem; font-weight: 700; color: var(--text-primary); margin: 0 0 1.5rem 0; text-align: center;">
                    Metro Manila
                </h2>
                <div style="font-size: 3rem; margin-bottom: 1rem;">${icon}</div>
                <div class="recommendation-badge ${rec.className}">${rec.emoji} ${title}</div>
                <p class="recommendation-context">${message}</p>
                ${distributionHtml}
                ${exceptionHtml}
                <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(0,0,0,0.03); border-radius: 12px; font-size: 0.9rem; color: var(--text-secondary);">
                    💡 Select your specific LGU from the dropdown above to see detailed hourly forecast
                </div>
            `;
        }

        function renderLGUDetails(lguName) {
            const lguData = appState.predictionData.predictions.find(p => p.lgu === lguName);
            if (!lguData) return;
            
            // Check if risk tier data exists (new format)
            const riskTier = lguData.risk_tier || null;
            const weatherContext = lguData.weather_context || null;
            
            renderLGUPredictionCard(lguData, riskTier, weatherContext);
            // renderWeatherMetrics([lguData]); // Removed - metrics now in card
            // renderRecommendationReasons(lguData); // Removed - not needed
            
            // Fetch hourly data and render new charts (Key Hours + Rain Chart)
            fetchAndRenderNewCharts(lguName);
        }

        function renderLGUPredictionCard(lguData, riskTier, weatherContext) {
            // Helper function to normalize tier names
            function normalizeTier(tier) {
                if (tier === 'suspension') return 'RED';
                if (tier === 'alert') return 'ORANGE';
                if (tier === 'normal') return 'GREEN';
                return tier?.toUpperCase() || 'GREEN';
            }
            
            // Determine tier info
            let tierEmoji, tierTitle, tierClassName, tierActions, weatherDesc, pagasaAdvisory;
            const normalizedTier = riskTier ? normalizeTier(riskTier.tier) : 
                (lguData.suspension_probability >= 0.7 ? 'RED' : 
                 lguData.suspension_probability >= 0.4 ? 'ORANGE' : 'GREEN');
            
            // Get weather data
            const weather = appState.predictionData?.weather || {};
            const rainfall = weather.precipitation_sum_mm || 0;
            const windSpeed = weather.wind_speed_max_kmh || 0;
            const maxTemp = weather.temperature_max_c || 0;
            const avgHumidity = weather.humidity_mean_pct || 0;
            
            // Determine PAGASA advisory based on data
            const pagasaStatus = appState.predictionData?.pagasa_status;
            
            // Build typhoon warning if active
            let typhoonWarning = '';
            if (pagasaStatus?.has_active_typhoon || pagasaStatus?.hasActiveTyphoon) {
                const isDirect = pagasaStatus.metro_manila_affected || pagasaStatus.metroManilaAffected;
                const typhoonName = pagasaStatus.typhoon_name || pagasaStatus.typhoonName;
                const tcwsLevel = pagasaStatus.tcws_level || pagasaStatus.tcwsLevel || 0;
                
                typhoonWarning = `
                    <div style="background: ${isDirect ? 'rgba(220, 53, 69, 0.15)' : 'rgba(255, 193, 7, 0.15)'}; border-left: 3px solid ${isDirect ? '#dc3545' : '#ffc107'}; padding: 1rem 1.25rem; border-radius: 8px; margin-bottom: 2rem;">
                        <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; font-size: 1rem;">🌀 ${isDirect ? 'TYPHOON WARNING' : 'TYPHOON ALERT'}:</div>
                        <div style="color: #666; font-size: 1rem; line-height: 1.6;">
                            ${typhoonName ? `<strong>${typhoonName}</strong> is ${isDirect ? `affecting Metro Manila (TCWS #${tcwsLevel})` : 'being monitored in the region'}. Stay alert and monitor PAGASA updates.` : `Active tropical cyclone detected in the region. ${isDirect ? 'Metro Manila may be affected.' : ''} Monitor PAGASA for updates.`}
                        </div>
                    </div>
                `;
            }
            
            // Build rainfall warning
            if (pagasaStatus?.has_rainfall_warning && pagasaStatus.rainfall_warning_level === 3) {
                pagasaAdvisory = '🔴 PAGASA Red Rainfall Warning';
            } else if (pagasaStatus?.has_rainfall_warning && pagasaStatus.rainfall_warning_level === 2) {
                pagasaAdvisory = '🟠 PAGASA Orange Rainfall Advisory';
            } else if (pagasaStatus?.has_rainfall_warning && pagasaStatus.rainfall_warning_level === 1) {
                pagasaAdvisory = '🟡 PAGASA Yellow Rainfall Advisory';
            } else {
                pagasaAdvisory = null;
            }
            
            if (normalizedTier === 'RED') {
                tierEmoji = '🔴';
                tierTitle = 'HIGH RISK';
                tierClassName = 'suspend';
                weatherDesc = '🌊 Severe Weather Expected';
                tierActions = [
                    'Class suspension STRONGLY RECOMMENDED',
                    'Avoid flood-prone areas',
                    'Monitor emergency announcements closely'
                ];
            } else if (normalizedTier === 'ORANGE') {
                tierEmoji = '🟠';
                tierTitle = 'ALERT';
                tierClassName = 'monitor';
                weatherDesc = '🌧️ Heavy Rain Expected';
                tierActions = [
                    'Check school announcements by 6 PM today',
                    'Stay updated on weather and flood warnings',
                    'Have emergency contacts ready'
                ];
            } else {
                tierEmoji = '🟢';
                tierTitle = 'NORMAL';
                tierClassName = 'classes-expected';
                weatherDesc = '☀️ Fair Weather Expected';
                tierActions = [
                    'Proceed with normal school operations',
                    'Continue routine weather monitoring'
                ];
            }
            
            dom.predictionCard.className = `prediction-card bg-${tierClassName}`;
            
            // Get nearby LGUs with their tiers
            const allPredictions = appState.predictionData.predictions || [];
            const nearbyLgus = allPredictions
                .filter(p => p.lgu !== lguData.lgu)
                .slice(0, 3)
                .map(p => {
                    const tier = normalizeTier(p.risk_tier?.tier || p.tier);
                    const emoji = tier === 'RED' ? '🔴' : tier === 'ORANGE' ? '🟠' : '🟢';
                    return `${p.lgu} ${emoji}`;
                })
                .join(' | ');
            
            // Build recommendation icon
            const recIcon = normalizedTier === 'RED' ? '⛔' : normalizedTier === 'ORANGE' ? '⚠️' : '✓';
            
            // Build emergency contacts for RED tier
            const emergencySection = normalizedTier === 'RED' ? `
                <div style="margin-top: 1.5rem; padding: 1rem; background: rgba(220, 53, 69, 0.1); border-radius: 8px;">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">🚨 Emergency Contacts:</div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary);">
                        NDRRMC: 911 | Local DRRM Office
                    </div>
                </div>
            ` : '';
            
            dom.predictionCard.innerHTML = `
                <h2 style="font-size: 2.25rem; font-weight: 700; color: var(--text-primary); margin: 0 0 1.5rem 0; text-align: center;">
                    ${lguData.lgu}
                </h2>
                ${normalizedTier === 'ORANGE' || normalizedTier === 'RED' ? '<div style="font-size: 3rem; margin-bottom: 1rem; text-align: center;">⚠️</div>' : ''}
                <div class="recommendation-badge ${tierClassName}" style="margin-bottom: 2rem;">${tierEmoji} ${tierTitle}</div>
                
                <!-- Typhoon Warning (if active) -->
                ${typhoonWarning}
                
                <!-- Weather Interpretation Box -->
                <div style="background: ${normalizedTier === 'RED' ? 'rgba(244, 67, 54, 0.1)' : normalizedTier === 'ORANGE' ? 'rgba(255, 152, 0, 0.1)' : 'rgba(76, 175, 80, 0.1)'}; border-left: 3px solid ${normalizedTier === 'RED' ? '#f44336' : normalizedTier === 'ORANGE' ? '#ff9800' : '#4caf50'}; padding: 1rem 1.25rem; border-radius: 8px; margin-bottom: 2rem; ${typhoonWarning ? 'margin-top: 0;' : 'margin-top: 0;'}">
                    <div style="font-weight: 600; color: var(--text-primary); margin-bottom: 0.5rem; font-size: 1rem;">🌤️ Weather Conditions:</div>
                    <div style="color: #666; font-size: 1rem; line-height: 1.6;">
                        ${getWeatherInterpretation(rainfall, windSpeed, avgHumidity, normalizedTier)}
                    </div>
                </div>
                
                <!-- Minimalist Weather Metrics (Larger fonts) -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 1rem; margin: 2rem 0; padding: 1rem 0; border-top: 1px solid rgba(0,0,0,0.06); border-bottom: 1px solid rgba(0,0,0,0.06);">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">🌧️</div>
                        <div style="font-size: 1.35rem; font-weight: 600; color: var(--text-primary);">${rainfall.toFixed(1)}mm</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); opacity: 0.8;">Rainfall</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">💨</div>
                        <div style="font-size: 1.35rem; font-weight: 600; color: var(--text-primary);">${windSpeed.toFixed(0)} km/h</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); opacity: 0.8;">Wind</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">🌡️</div>
                        <div style="font-size: 1.35rem; font-weight: 600; color: var(--text-primary);">${maxTemp.toFixed(1)}°C</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); opacity: 0.8;">Temp</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; margin-bottom: 0.5rem;">💧</div>
                        <div style="font-size: 1.35rem; font-weight: 600; color: var(--text-primary);">${avgHumidity.toFixed(0)}%</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); opacity: 0.8;">Humidity</div>
                    </div>
                </div>
                
                ${pagasaAdvisory ? `<div style="margin-bottom: 2rem; padding: 1rem 1.25rem; background: ${pagasaAdvisory.includes('Red') ? 'rgba(220, 53, 69, 0.15)' : pagasaAdvisory.includes('Orange') ? 'rgba(255, 152, 0, 0.15)' : 'rgba(255, 193, 7, 0.15)'}; border-left: 3px solid ${pagasaAdvisory.includes('Red') ? '#dc3545' : pagasaAdvisory.includes('Orange') ? '#ff9800' : '#ffc107'}; border-radius: 8px; font-size: 1rem; font-weight: 600; color: var(--text-primary);">
                    <div style="margin-bottom: 0.25rem;">${pagasaAdvisory}</div>
                    <div style="font-size: 0.9rem; font-weight: 400; color: #666; margin-top: 0.5rem;">Heavy rainfall expected. Monitor PAGASA for updates.</div>
                </div>` : ''}
                
                <div style="margin-bottom: 2rem; padding: 1.25rem; background: rgba(0,0,0,0.03); border-radius: 12px; font-size: 1rem; color: var(--text-secondary); line-height: 1.7;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary); font-size: 1.05rem;">${recIcon} RECOMMENDATION:</div>
                    ${tierActions.map(action => `<div style="margin-bottom: 0.35rem;">• ${action}</div>`).join('')}
                </div>
                
                <div style="margin-bottom: 2rem; padding: 1.25rem; background: rgba(0,0,0,0.03); border-radius: 12px; font-size: 1rem; color: var(--text-secondary); line-height: 1.7;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary); font-size: 1.05rem;">📱 Get Updates:</div>
                    <div style="margin-bottom: 0.35rem;">• ${lguData.lgu} LGU Facebook/Website</div>
                    <div style="margin-bottom: 0.35rem;">• PAGASA Weather Updates</div>
                    <div>• DepEd-NCR Announcements</div>
                </div>
                
                <div style="padding: 1.25rem; background: rgba(0,0,0,0.03); border-radius: 12px; font-size: 1rem; color: var(--text-secondary); line-height: 1.7;">
                    <div style="font-weight: 600; margin-bottom: 0.75rem; color: var(--text-primary); font-size: 1.05rem;">📍 Nearby LGUs:</div>
                    ${nearbyLgus || 'No nearby data'}
                </div>
                
                ${emergencySection}
            `;
        }
        
        async function fetchAndRenderNewCharts(lguName) {
            const coords = LGU_COORDS[lguName]; 
            if (!coords) return;
            
            const cacheKey = `${CACHE_KEYS.HOURLY_WEATHER}${lguName.replace(/ /g, '_')}`;
            let weatherData = getCache(cacheKey);
            
            if (!weatherData) {
                try { 
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&hourly=temperature_2m,apparent_temperature,precipitation,precipitation_probability,weather_code&timezone=Asia/Manila&forecast_days=2`;
                    console.log('Fetching from OpenMeteo:', url);
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('OpenMeteo API error');
                    weatherData = await response.json();
                    console.log('OpenMeteo Response:', weatherData);
                    console.log('Precipitation data:', weatherData.hourly?.precipitation);
                    console.log('Precipitation probability data:', weatherData.hourly?.precipitation_probability);
                    setCache(cacheKey, weatherData, CACHE_DURATION.HOURLY_WEATHER);
                } catch (error) { 
                    console.error('Failed to fetch weather data:', error);
                    return; 
                }
            } else {
                console.log('Using cached weather data:', weatherData);
                console.log('Cached Precipitation data:', weatherData.hourly?.precipitation);
                console.log('Cached Precipitation probability data:', weatherData.hourly?.precipitation_probability);
            }            const now = new Date(); 
            now.setMinutes(0, 0, 0);
            const startIndex = weatherData.hourly.time.findIndex(t => new Date(t) >= now);
            if (startIndex === -1) return;
            
            renderKeyHours(weatherData, startIndex);
            renderRainChart(weatherData, startIndex);
        }
        
        function getWeatherInterpretation(rainfall, windSpeed, humidity, normalizedTier) {
            // Rule-based weather interpretation based on metrics and tier
            let rainDesc = rainfall < 1 ? 'Minimal rain' : rainfall < 5 ? 'Light rain' : rainfall < 20 ? 'Moderate rain' : rainfall < 40 ? 'Heavy rain' : 'Very heavy rain';
            let windDesc = windSpeed < 20 ? 'light winds' : windSpeed < 40 ? 'moderate winds' : windSpeed < 60 ? 'strong winds' : 'very strong winds';
            let humidityDesc = humidity < 60 ? 'moderate' : humidity < 75 ? 'high' : humidity < 85 ? 'very high' : 'extremely high';
            
            let context = '';
            if (normalizedTier === 'RED') {
                context = rainfall >= 40 ? 'Flooding expected in low-lying areas.' : 'Severe weather conditions developing.';
            } else if (normalizedTier === 'ORANGE') {
                context = 'Conditions may worsen.';
            } else {
                context = rainfall < 1 ? 'Good weather for classes.' : 'Generally safe conditions.';
            }
            
            return `${rainDesc} with ${windDesc}. Humidity is ${humidityDesc}. ${context}`;
        }

        function renderPredictionCard(recommendation, probability, riskTier = null, weatherContext = null) {
            // Risk tier takes precedence if available
            if (riskTier) {
                renderRiskTierCard(riskTier, weatherContext, probability);
                return;
            }
            
            // Fallback to legacy rendering
            const recMap = { proceed: { text: 'Classes Expected', className: 'classes-expected', context: "Weather conditions appear stable." }, monitor: { text: 'Monitor', className: 'monitor', context: "Weather is uncertain. Monitor official announcements." }, suspend: { text: 'Suspend', className: 'suspend', context: "Hazardous weather is predicted, suspension is likely." } };
            const rec = recMap[recommendation.toLowerCase()] || recMap.monitor;
            let weatherEmoji = probability > 0.7 ? '⛈️' : probability > 0.5 ? '🌧️' : probability > 0.2 ? '🌦️' : '⛅';
            dom.predictionCard.className = `prediction-card bg-${rec.className}`;
            dom.predictionCard.innerHTML = `<div class="recommendation-badge ${rec.className}">${rec.text}</div><p class="recommendation-context">${rec.context}</p><div><span class="probability-value">${(probability * 100).toFixed(0)}%</span><span class="probability-label">Chance of Suspension</span></div><div class="weather-icon-large">${weatherEmoji}</div>`;
        }
        
        function renderRiskTierCard(riskTier, weatherContext, probability) {
            const tierColorMap = {
                'normal': { bg: 'linear-gradient(135deg, #d1fae5, #f8f9fa)', border: '#22c55e', text: '#065f46' },
                'alert': { bg: 'linear-gradient(135deg, #fef3c7, #f8f9fa)', border: '#f97316', text: '#92400e' },
                'suspension': { bg: 'linear-gradient(135deg, #fee2e2, #f8f9fa)', border: '#ef4444', text: '#991b1b' }
            };
            
            const colors = tierColorMap[riskTier.tier] || tierColorMap.alert;
            dom.predictionCard.style.background = colors.bg;
            dom.predictionCard.style.border = `4px solid ${colors.border}`;
            
            let actionsHtml = '';
            if (riskTier.actions && riskTier.actions.length > 0) {
                actionsHtml = `
                    <div class="risk-tier-actions">
                        <h4 style="font-size: 0.9rem; font-weight: 700; color: #666; text-transform: uppercase; letter-spacing: 1px; margin: 1.5rem 0 1rem 0;">
                            ${riskTier.tier === 'suspension' ? '🚨 Immediate Actions' : '📋 Recommended Actions'}
                        </h4>
                        <ul style="list-style: none; padding: 0; margin: 0; text-align: left; max-width: 500px; margin: 0 auto;">
                            ${riskTier.actions.slice(0, 5).map(action => `
                                <li style="padding: 0.5rem 0 0.5rem 1.75rem; position: relative; color: #333; font-size: 0.95rem; line-height: 1.5;">
                                    <span style="position: absolute; left: 0; font-weight: bold; color: ${colors.border};">✓</span>
                                    ${action}
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }
            
            let weatherContextHtml = '';
            if (weatherContext) {
                weatherContextHtml = `
                    <div class="weather-context-display" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 2px solid rgba(0,0,0,0.1);">
                        ${weatherContext.weather_desc ? `
                            <div style="text-align: center; margin-bottom: 1rem;">
                                <div style="font-size: 0.75rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">📍 Conditions</div>
                                <div style="font-size: 1.1rem; font-weight: 700; color: #111;">${weatherContext.weather_desc}</div>
                            </div>
                        ` : ''}
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-top: 0.75rem;">
                            ${weatherContext.precipitation ? `
                                <div style="text-align: center; padding: 0.75rem; background: rgba(59, 130, 246, 0.1); border-radius: 8px;">
                                    <div style="font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">💧 Rain</div>
                                    <div style="font-size: 1.1rem; font-weight: 700; color: #1e40af;">${weatherContext.precipitation}</div>
                                </div>
                            ` : ''}
                            ${weatherContext.temperature ? `
                                <div style="text-align: center; padding: 0.75rem; background: rgba(239, 68, 68, 0.1); border-radius: 8px;">
                                    <div style="font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">🌡️ Temp</div>
                                    <div style="font-size: 1.1rem; font-weight: 700; color: #991b1b;">${weatherContext.temperature}</div>
                                </div>
                            ` : ''}
                            ${weatherContext.wind_speed ? `
                                <div style="text-align: center; padding: 0.75rem; background: rgba(34, 197, 94, 0.1); border-radius: 8px;">
                                    <div style="font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">💨 Wind</div>
                                    <div style="font-size: 1.1rem; font-weight: 700; color: #166534;">${weatherContext.wind_speed}</div>
                                </div>
                            ` : ''}
                            ${weatherContext.humidity ? `
                                <div style="text-align: center; padding: 0.75rem; background: rgba(168, 85, 247, 0.1); border-radius: 8px;">
                                    <div style="font-size: 0.7rem; color: #666; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">💦 Humidity</div>
                                    <div style="font-size: 1.1rem; font-weight: 700; color: #6b21a8;">${weatherContext.humidity}</div>
                                </div>
                            ` : ''}
                        </div>
                        ${weatherContext.pagasa_advisory ? `
                            <div style="text-align: center; margin-top: 1rem; padding: 0.75rem; background: rgba(234, 179, 8, 0.15); border-radius: 8px; border: 2px solid #eab308;">
                                <div style="font-size: 0.75rem; color: #854d0e; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 0.25rem;">⚠️ PAGASA Advisory</div>
                                <div style="font-size: 1rem; font-weight: 700; color: #854d0e;">${weatherContext.pagasa_advisory.replace('PAGASA: ', '')}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            let monitoringHtml = '';
            if (riskTier.monitoring_interval) {
                const monitoringColors = {
                    'normal': { bg: '#d1fae5', text: '#065f46' },
                    'alert': { bg: '#fef3c7', text: '#92400e' },
                    'suspension': { bg: '#fee2e2', text: '#991b1b' }
                };
                const monColor = monitoringColors[riskTier.tier];
                const monIcon = riskTier.tier === 'suspension' ? '🚨' : riskTier.tier === 'alert' ? '⏰' : '📅';
                monitoringHtml = `
                    <div style="text-align: center; padding: 0.75rem; background: ${monColor.bg}; border-radius: 8px; margin-top: 1.5rem; font-size: 0.9rem; font-weight: 600; color: ${monColor.text};">
                        ${monIcon} ${riskTier.monitoring_interval}
                    </div>
                `;
            }
            
            dom.predictionCard.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; margin-bottom: 1rem;">
                    <div style="font-size: 3.5rem;">${riskTier.emoji}</div>
                    <div style="text-align: left;">
                        <h2 style="margin: 0; font-size: 1.8rem; font-weight: 900; color: #333; letter-spacing: 1px;">${riskTier.title}</h2>
                        <p style="margin: 0.25rem 0 0 0; font-size: 1rem; color: #666;">${riskTier.subtitle}</p>
                    </div>
                </div>
                
                <div style="background: rgba(255,255,255,0.6); padding: 1rem 1.5rem; border-radius: 12px; margin: 1rem 0;">
                    <h3 style="margin: 0 0 0.5rem 0; font-size: 0.85rem; font-weight: 700; color: #666;">${riskTier.status_icon} Recommendation</h3>
                    <p style="margin: 0; font-size: 1.3rem; font-weight: 700; color: #111;">${riskTier.recommendation}</p>
                </div>
                
                ${actionsHtml}
                ${weatherContextHtml}
                ${monitoringHtml}
            `;
        }

        function renderWeatherMetrics(dataArray) {
            if (!dom.weatherMetricsSection) return; // Skip if element doesn't exist
            dom.weatherMetricsSection.style.display = 'block';
            
            // Get weather data from top-level or from prediction
            const weather = appState.predictionData?.weather || {};
            const avgRain = (weather.precipitation_sum_mm || 0).toFixed(1);
            const maxWind = (weather.wind_speed_max_kmh || 0).toFixed(0);
            const maxTemp = (weather.temperature_max_c || 0).toFixed(1);
            const avgHumidity = (weather.humidity_mean_pct || 0).toFixed(0);
            
            const rainCtx = avgRain < 15 ? { text: 'Light to Moderate' } : { text: 'Heavy Rain', class: 'danger' };
            const windCtx = maxWind < 62 ? { text: 'Light to Strong' } : { text: 'Gale Force', class: 'danger' };
            
            dom.weatherMetricsGrid.innerHTML = `
                <div class="weather-metric">
                    <div class="metric-icon-wrapper"><i data-lucide="cloud-rain"></i></div>
                    <div class="metric-content">
                        <div class="metric-label">Rainfall (24h)</div>
                        <div class="metric-value-wrapper">
                            <span class="metric-value">${avgRain}mm</span>
                            <span class="metric-context ${rainCtx.class||''}">${rainCtx.text}</span>
                        </div>
                    </div>
                </div>
                <div class="weather-metric">
                    <div class="metric-icon-wrapper"><i data-lucide="wind"></i></div>
                    <div class="metric-content">
                        <div class="metric-label">Max Wind</div>
                        <div class="metric-value-wrapper">
                            <span class="metric-value">${maxWind} km/h</span>
                            <span class="metric-context ${windCtx.class||''}">${windCtx.text}</span>
                        </div>
                    </div>
                </div>
                <div class="weather-metric">
                    <div class="metric-icon-wrapper"><i data-lucide="thermometer"></i></div>
                    <div class="metric-content">
                        <div class="metric-label">Max Temperature</div>
                        <div class="metric-value-wrapper">
                            <span class="metric-value">${maxTemp}°C</span>
                        </div>
                    </div>
                </div>
                <div class="weather-metric">
                    <div class="metric-icon-wrapper"><i data-lucide="droplets"></i></div>
                    <div class="metric-content">
                        <div class="metric-label">Humidity</div>
                        <div class="metric-value-wrapper">
                            <span class="metric-value">${avgHumidity}%</span>
                        </div>
                    </div>
                </div>
            `;
            lucide.createIcons();
        }
        
        function renderRecommendationReasons(lguData) {
            dom.reasonsList.innerHTML = '';
            let hasReasons = false;
            
            // Check for typhoon from top-level pagasa_status or lgu-level
            const pagasa = appState.predictionData?.pagasa_status || lguData?.pagasa_status;
            if (pagasa?.has_active_typhoon && pagasa.typhoon_name) {
                dom.reasonsList.innerHTML += `<div class="reason-item typhoon-reason"><i data-lucide="cyclone"></i><span>Official warning for <strong>${pagasa.typhoon_name}</strong> (TCWS #${pagasa.tcws_level || 0}) is a primary factor.</span></div>`;
                hasReasons = true;
            }
            
            // Check weather factors from top-level weather data
            const weather = appState.predictionData?.weather || {};
            const rainfall = weather.precipitation_sum_mm || 0;
            const windSpeed = weather.wind_speed_max_kmh || 0;
            
            if (rainfall > 30 || windSpeed > 60) {
                let riskFactors = [];
                if (rainfall > 30) riskFactors.push(`heavy rain (${rainfall.toFixed(1)}mm)`);
                if (windSpeed > 60) riskFactors.push(`strong winds (${windSpeed.toFixed(0)} km/h)`);
                dom.reasonsList.innerHTML += `<div class="reason-item model-reason"><i data-lucide="brain-circuit"></i><span>AI model predicts high risk due to: ${riskFactors.join(' and ')}.</span></div>`;
                hasReasons = true;
            }
            
            // Show risk tier recommendation if available
            if (lguData?.risk_tier?.recommendation) {
                dom.reasonsList.innerHTML += `<div class="reason-item model-reason"><i data-lucide="shield-alert"></i><span>${lguData.risk_tier.recommendation}</span></div>`;
                hasReasons = true;
            }
            
            dom.reasonsContainer.style.display = hasReasons ? 'block' : 'none';
            lucide.createIcons();
        }

        async function renderHourlyForecast(lguName) {
            dom.hourlyForecastSection.style.display = 'block';
            const coords = LGU_COORDS[lguName]; if (!coords) return;
            const cacheKey = `${CACHE_KEYS.HOURLY_WEATHER}${lguName.replace(/ /g, '_')}`;
            let weatherData = getCache(cacheKey);
            if (!weatherData) {
                try {
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&hourly=temperature_2m,apparent_temperature,precipitation_probability,precipitation,weather_code&timezone=Asia/Manila&forecast_days=2`;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('OpenMeteo API error');
                    weatherData = await response.json();
                    setCache(cacheKey, weatherData, CACHE_DURATION.HOURLY_WEATHER);
                } catch (error) { dom.hourlyForecastSection.style.display = 'none'; return; }
            }
            const now = new Date(); now.setMinutes(0, 0, 0);
            const startIndex = weatherData.hourly.time.findIndex(t => new Date(t) >= now);
            if (startIndex === -1) { dom.hourlyForecastSection.style.display = 'none'; return; }
            const hourlyItems = weatherData.hourly.time.slice(startIndex, startIndex + 24).map((time, i) => {
                const index = startIndex + i;
                return `<div class="hourly-list-item"><span class="time">${i === 0 ? '<strong>Now</strong>' : new Date(time).toLocaleTimeString('en-US', { hour: 'numeric', hour12: true })}</span><span class="icon">${getWeatherIconFromCode(weatherData.hourly.weather_code[index])}</span><span class="temp">${Math.round(weatherData.hourly.temperature_2m[index])}°</span><span class="realfeel">Feels ${Math.round(weatherData.hourly.apparent_temperature[index])}°</span><div class="precip-details"><span class="precip"><i data-lucide="droplet"></i> ${weatherData.hourly.precipitation_probability[index]}%</span><span class="rainfall">${weatherData.hourly.precipitation[index].toFixed(1)} mm</span></div></div>`;
            }).join('');
            dom.hourlyListView.innerHTML = hourlyItems;
            lucide.createIcons();
        }

        function renderKeyHours(weatherData, startIndex) {
            const keyHoursSection = document.getElementById('keyHoursSection');
            const keyHoursGrid = document.getElementById('keyHoursGrid');
            
            // Define key time periods
            const periods = [
                { name: '🌅 Morning Commute', start: 6, end: 8, key: 'morning' },
                { name: '🏫 School Hours', start: 9, end: 15, key: 'school' },
                { name: '🌆 Evening Commute', start: 16, end: 18, key: 'evening' }
            ];
            
            const now = new Date();
            const currentHour = now.getHours();
            
            let html = '';
            periods.forEach(period => {
                // Find data for this period
                const periodData = [];
                for (let hour = period.start; hour <= period.end; hour++) {
                    const targetDate = new Date(now);
                    targetDate.setHours(hour, 0, 0, 0);
                    
                    const index = weatherData.hourly.time.findIndex(t => {
                        const d = new Date(t);
                        return d.getHours() === hour && d.getDate() === targetDate.getDate();
                    });
                    
                    if (index !== -1) {
                        periodData.push({
                            prob: weatherData.hourly.precipitation_probability[index],
                            rain: weatherData.hourly.precipitation[index]
                        });
                    }
                }
                
                if (periodData.length === 0) return;
                
                // Calculate average probability and max rainfall
                const avgProb = Math.round(periodData.reduce((sum, d) => sum + d.prob, 0) / periodData.length);
                const maxRain = Math.max(...periodData.map(d => d.rain));
                const avgRain = periodData.reduce((sum, d) => sum + d.rain, 0) / periodData.length;
                
                // Determine alert level - use BOTH probability AND rainfall amount
                let alertClass = 'safe';
                let recommendation = '✅ Low rain risk';
                
                // High risk: high probability AND significant rainfall, OR very high probability
                if ((avgProb >= 60 && maxRain >= 5) || avgProb >= 80 || maxRain >= 15) {
                    alertClass = 'warning';
                    recommendation = '⚠️ High rain risk - prepare accordingly';
                }
                // Moderate risk: moderate probability with some rain expected
                else if ((avgProb >= 40 && maxRain >= 2) || (avgProb >= 50 && maxRain >= 1) || maxRain >= 8) {
                    alertClass = 'caution';
                    recommendation = '🌂 Moderate rain risk - bring umbrella';
                }
                // Low risk but still some chance: show probability but don't alarm
                else if (avgProb >= 30 || maxRain >= 0.5) {
                    alertClass = 'safe';
                    recommendation = '✅ Low rain risk - likely dry';
                }
                
                html += `
                    <div class="hour-alert ${alertClass}">
                        <div class="hour-alert-title">${period.name} (${period.start > 12 ? period.start-12 : period.start}-${period.end > 12 ? period.end-12 : period.end}${period.end >= 12 ? 'PM' : 'AM'})</div>
                        <div class="hour-alert-detail">
                            <strong>${avgProb}%</strong> chance of rain
                            <div class="rain-indicator"><div class="rain-fill" style="width: ${avgProb}%"></div></div>
                        </div>
                        <div class="hour-alert-detail">💧 Expected: <strong>${maxRain < 0.5 ? 'Minimal' : (avgRain.toFixed(1) + (maxRain > avgRain + 0.5 ? '-' + maxRain.toFixed(1) : '') + 'mm')}</strong></div>
                        <div class="hour-alert-detail">${recommendation}</div>
                    </div>
                `;
            });
            
            keyHoursGrid.innerHTML = html;
            keyHoursSection.style.display = 'block';
        }

        function renderRainChart(weatherData, startIndex) {
            const rainChartSection = document.getElementById('rainChartSection');
            const header = document.getElementById('rainChartHeader');
            const barsContainer = document.getElementById('rainBarsContainer');
            const footer = document.getElementById('rainChartFooter');
            
            // Get 12 hours of data starting from now
            const hours = 12;
            const chartData = [];
            
            console.log('Rain Chart - Weather Data:', weatherData);
            console.log('Rain Chart - Precipitation array:', weatherData.hourly.precipitation);
            
            for (let i = 0; i < hours; i++) {
                const index = startIndex + i;
                if (index >= weatherData.hourly.time.length) break;
                
                const time = new Date(weatherData.hourly.time[index]);
                const hour = time.getHours();
                
                // Determine if day or night (6 AM to 6 PM is day)
                const isDaytime = hour >= 6 && hour < 18;
                const dayNightEmoji = isDaytime ? '☀️' : '🌙';
                
                const rainfall = weatherData.hourly.precipitation[index] || 0;
                
                chartData.push({
                    time: time.toLocaleTimeString('en-US', { hour: 'numeric', hour12: true }),
                    temp: Math.round(weatherData.hourly.temperature_2m[index]),
                    icon: getWeatherIconFromCode(weatherData.hourly.weather_code[index], hour),
                    rainfall: rainfall,
                    probability: weatherData.hourly.precipitation_probability[index] || 0,
                    dayNightEmoji: dayNightEmoji
                });
            }
            
            console.log('Rain Chart - Chart Data:', chartData);
            
            // Helper function to get temperature gradient
            function getTempGradient(temp) {
                if (temp <= 32) return 'linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%)';
                else if (temp <= 36) return 'linear-gradient(135deg, #fff9c4 0%, #fff59d 100%)';
                else if (temp <= 39) return 'linear-gradient(135deg, #ffe0b2 0%, #ffcc80 100%)';
                else return 'linear-gradient(135deg, #ffcdd2 0%, #ef9a9a 100%)';
            }
            
            // Render header
            header.innerHTML = chartData.map((data, i) => `
                <div class="hour-header" data-index="${i}" style="background: ${getTempGradient(data.temp)}">
                    <div class="header-icon">${data.icon}</div>
                    <div class="header-temp">${data.temp}°C</div>
                </div>
            `).join('');
            
            // Render bars
            const maxRain = Math.max(...chartData.map(d => d.rainfall), 0.1);
            barsContainer.innerHTML = chartData.map((data, i) => {
                const barHeight = (data.rainfall / maxRain) * 180;
                const opacity = data.probability / 100;
                return `
                    <div class="rainfall-column" data-index="${i}">
                        <div class="rain-bar-fill" style="height: ${barHeight}px; opacity: ${opacity};">
                            <div class="rain-amount">${data.rainfall.toFixed(1)}mm</div>
                            <div class="rain-probability">${data.probability}% chance</div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Render footer with day/night emoji
            footer.innerHTML = chartData.map(data => `
                <div class="hour-time">${data.dayNightEmoji} ${data.time}</div>
            `).join('');
            
            // Add hover and click events for desktop and mobile
            const tooltip = document.getElementById('rainTooltip');
            let activeElement = null;
            
            document.querySelectorAll('.hour-header, .rainfall-column').forEach((el) => {
                const index = parseInt(el.dataset.index);
                
                // Desktop: hover events (work on all screen sizes)
                el.addEventListener('mouseenter', () => {
                    showRainTooltip(chartData[index], el, tooltip, rainChartSection);
                });
                el.addEventListener('mouseleave', () => {
                    hideRainTooltip(tooltip);
                });
                
                // Mobile: click/touch events for better touch interaction
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    // Remove active class from previous element
                    if (activeElement && activeElement !== el) {
                        activeElement.classList.remove('active');
                    }
                    
                    // Toggle current element
                    if (activeElement === el) {
                        el.classList.remove('active');
                        hideRainTooltip(tooltip);
                        activeElement = null;
                    } else {
                        el.classList.add('active');
                        showRainTooltip(chartData[index], el, tooltip, rainChartSection);
                        activeElement = el;
                    }
                });
            });
            
            // Close tooltip when clicking outside the chart area
            document.addEventListener('click', (e) => {
                if (activeElement && !rainChartSection.contains(e.target)) {
                    activeElement.classList.remove('active');
                    hideRainTooltip(tooltip);
                    activeElement = null;
                }
            });
            
            rainChartSection.style.display = 'block';
        }

        function showRainTooltip(data, element, tooltip, container) {
            let advisory = '';
            let advisoryClass = 'safe';
            
            if (data.probability >= 70 && data.rainfall >= 10) {
                advisory = '⚠️ <strong>Heavy rain expected!</strong> Bring umbrella and waterproof gear.';
                advisoryClass = 'warning';
            } else if (data.probability >= 50 || data.rainfall >= 5) {
                advisory = '🌂 <strong>Rain likely.</strong> Bring an umbrella.';
                advisoryClass = '';
            } else if (data.probability >= 30) {
                advisory = '🌤️ <strong>Light rain possible.</strong> Keep umbrella handy.';
                advisoryClass = '';
            } else {
                advisory = '✅ <strong>Low chance of rain.</strong> Should be mostly clear!';
                advisoryClass = 'safe';
            }
            
            tooltip.innerHTML = `
                <div class="tooltip-header">${data.icon} ${data.time} Weather Details</div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Temperature</span>
                    <span class="tooltip-value">${data.temp}°C</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Rain Probability</span>
                    <span class="tooltip-value" style="color: #ffc107;">${data.probability}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Expected Rainfall</span>
                    <span class="tooltip-value" style="color: #007bff;">${data.rainfall.toFixed(1)}mm</span>
                </div>
                <div class="tooltip-advisory ${advisoryClass}">${advisory}</div>
            `;
            
            // Make tooltip visible first to get accurate measurements
            tooltip.classList.add('show');
            tooltip.style.visibility = 'hidden'; // Hide visually but allow measurement
            
            // Force a reflow to ensure tooltip is rendered
            tooltip.offsetHeight;
            
            // Use fixed positioning relative to viewport
            const rect = element.getBoundingClientRect();
            const tooltipWidth = 280; // min-width from CSS
            const tooltipHeight = tooltip.offsetHeight;
            
            // Calculate horizontal position (try to center under element)
            let left = rect.left + (rect.width / 2) - (tooltipWidth / 2);
            
            // Keep tooltip within viewport horizontally
            const padding = 10;
            if (left < padding) left = padding;
            if (left + tooltipWidth > window.innerWidth - padding) {
                left = window.innerWidth - tooltipWidth - padding;
            }
            
            // Calculate vertical position (above element with 10px gap)
            let top = rect.top - tooltipHeight - 10;
            
            // If tooltip would go above viewport, show it below instead
            if (top < padding) {
                top = rect.bottom + 10;
            }
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
            
            // Now make it visible
            tooltip.style.visibility = 'visible';
        }

        function hideRainTooltip(tooltip) {
            tooltip.classList.remove('show');
            tooltip.style.visibility = 'visible'; // Reset for next show
        }

        function renderTyphoonAlert() {
            // Check top-level pagasa_status first, then fall back to first prediction
            const pagasa = appState.predictionData?.pagasa_status || appState.predictionData?.predictions?.[0]?.pagasa_status;
            
            if (pagasa?.has_active_typhoon || pagasa?.hasActiveTyphoon) {
                const isDirect = pagasa.metro_manila_affected || pagasa.metroManilaAffected;
                const typhoonName = pagasa.typhoon_name || pagasa.typhoonName;
                const tcwsLevel = pagasa.tcws_level || pagasa.tcwsLevel || 0;
                
                dom.typhoonAlert.style.display = 'flex';
                dom.typhoonAlert.className = isDirect ? 'alert-box typhoon-direct' : 'alert-box';
                
                if (typhoonName) {
                    dom.typhoonAlert.innerHTML = `<i data-lucide="${isDirect ? 'alert-triangle' : 'wind'}"></i> <span>TYPHOON ${isDirect ? 'WARNING' : 'ALERT'}: <strong>${typhoonName}</strong> is ${isDirect ? `affecting Metro Manila (TCWS #${tcwsLevel})` : 'being monitored in the region'}.</span>`;
                } else {
                    dom.typhoonAlert.innerHTML = `<i data-lucide="wind"></i> <span>TYPHOON ALERT: Active tropical cyclone detected in the region. Monitor PAGASA for updates.</span>`;
                }
            } else { 
                dom.typhoonAlert.style.display = 'none'; 
            }
        }

        function renderRainfallAlert() {
            // Check top-level pagasa_status first, then fall back to first prediction
            const pagasaTop = appState.predictionData?.pagasa_status;
            const rainfallWarning = appState.predictionData?.predictions?.[0]?.pagasa_status?.rainfallWarning;
            
            // Check top-level first (has_rainfall_warning, rainfall_warning_level)
            if (pagasaTop && (pagasaTop.has_rainfall_warning || pagasaTop.rainfall_warning_level)) {
                const level = pagasaTop.rainfall_warning_level;
                
                if (level > 0) {
                    dom.rainfallAlert.style.display = 'flex';
                    
                    // Map numeric level to color names
                    const levelMap = {
                        3: { name: 'RED', class: 'rainfall-red', icon: 'cloud-rain', title: '🔴 RED RAINFALL WARNING' },
                        2: { name: 'ORANGE', class: 'rainfall-orange', icon: 'cloud-rain', title: '🟠 ORANGE RAINFALL WARNING' },
                        1: { name: 'YELLOW', class: 'rainfall-yellow', icon: 'cloud-rain', title: '🟡 YELLOW RAINFALL WARNING' }
                    };
                    
                    const warningInfo = levelMap[level] || levelMap[1];
                    
                    dom.rainfallAlert.className = `alert-box ${warningInfo.class}`;
                    dom.rainfallAlert.innerHTML = `<i data-lucide="${warningInfo.icon}"></i> <span><strong>${warningInfo.title}</strong>: Heavy rainfall expected in Metro Manila. Monitor PAGASA advisories.</span>`;
                    return;
                }
            }
            
            // Fall back to detailed rainfall warning object from predictions
            if (!rainfallWarning) {
                dom.rainfallAlert.style.display = 'none';
                return;
            }

            // Check if there's an active warning OR if Metro Manila is mentioned
            const hasWarning = rainfallWarning.hasActiveWarning || rainfallWarning.metroManilaStatus;
            
            if (!hasWarning) {
                dom.rainfallAlert.style.display = 'none';
                return;
            }

            dom.rainfallAlert.style.display = 'flex';
            
            // Determine alert class based on warning level
            let alertClass = 'alert-box rainfall-info';
            let icon = 'cloud-rain';
            let title = 'RAINFALL ADVISORY';
            
            if (rainfallWarning.warningLevel === 'RED') {
                alertClass = 'alert-box rainfall-red';
                icon = 'cloud-rain';
                title = '🔴 RED RAINFALL WARNING';
            } else if (rainfallWarning.warningLevel === 'ORANGE') {
                alertClass = 'alert-box rainfall-orange';
                icon = 'cloud-rain';
                title = '🟠 ORANGE RAINFALL WARNING';
            } else if (rainfallWarning.warningLevel === 'YELLOW') {
                alertClass = 'alert-box rainfall-yellow';
                icon = 'cloud-rain';
                title = '🟡 YELLOW RAINFALL WARNING';
            }
            
            dom.rainfallAlert.className = alertClass;
            
            // Build the message
            let message = `<strong>${title}</strong>`;
            
            if (rainfallWarning.warningTitle) {
                message = `<strong>${rainfallWarning.warningTitle}</strong>`;
            }
            
            if (rainfallWarning.metroManilaStatus) {
                message += `: ${rainfallWarning.metroManilaStatus}`;
            }
            
            if (rainfallWarning.hazards && rainfallWarning.hazards.length > 0) {
                message += ` <em>(${rainfallWarning.hazards.join(', ')})</em>`;
            }
            
            dom.rainfallAlert.innerHTML = `<i data-lucide="${icon}"></i> <span>${message}</span>`;
        }

        // --- 6. EVENT HANDLERS ---
        function handleLGUChange(value) { appState.selectedLGU = value; render(); }
        function handleRefresh() {
            if (dom.refreshBtn.classList.contains('spinning')) return;
            localStorage.removeItem(CACHE_KEYS.PREDICTIONS);
            Object.keys(localStorage).forEach(key => key.startsWith(CACHE_KEYS.HOURLY_WEATHER) && localStorage.removeItem(key));
            fetchPredictions(true);
        }

        // --- 7. FEEDBACK MODAL LOGIC (with web3forms) ---
        function openFeedbackModal() { dom.feedbackModal.classList.add('active'); lucide.createIcons(); }
        function closeFeedbackModal() {
            dom.feedbackModal.classList.remove('active');
            setTimeout(() => {
                dom.feedbackForm.style.display = 'block';
                dom.feedbackSuccess.style.display = 'none';
                resetFeedbackForm();
            }, 300);
        }

        window.selectRating = (type, value) => {
            appState.feedback[type] = value;
            document.getElementById(type + 'Input').value = value; // Update hidden input
            const container = document.getElementById(type + 'Rating');
            container.querySelectorAll('.rating-option').forEach(opt => opt.classList.remove('selected'));
            const selectedOpt = Array.from(container.children).find(child => child.getAttribute('onclick').includes(`, ${value})`));
            if (selectedOpt) selectedOpt.classList.add('selected');
        }

        function resetFeedbackForm() {
            appState.feedback = { helpfulness: null, trust: null, clarity: null };
            document.querySelectorAll('.rating-option.selected').forEach(el => el.classList.remove('selected'));
            dom.feedbackForm.reset(); // Resets all form fields
            // Clear hidden inputs
            document.getElementById('helpfulnessInput').value = '';
            document.getElementById('trustInput').value = '';
            document.getElementById('clarityInput').value = '';
        }

        async function handleFeedbackSubmit(event) {
            event.preventDefault();
            const { helpfulness, trust, clarity } = appState.feedback;
            if (helpfulness === null || trust === null || clarity === null) {
                alert('Please provide a rating for the first three questions before submitting.');
                return;
            }
            const form = event.target;
            const formData = new FormData(form);
            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.innerHTML = 'Submitting...';

            try {
                const response = await fetch(form.action, { method: 'POST', body: formData });
                const data = await response.json();
                if (data.success) {
                    dom.feedbackForm.style.display = 'none';
                    dom.feedbackSuccess.style.display = 'block';
                    lucide.createIcons();
                    setTimeout(closeFeedbackModal, 3000);
                } else {
                    console.error('Submission failed:', data);
                    alert(data.message || 'Sorry, there was an error submitting your feedback.');
                }
            } catch (error) {
                console.error('Error submitting feedback:', error);
                alert('An error occurred. Please try again.');
            } finally {
                submitButton.disabled = false;
                submitButton.innerHTML = 'Submit Feedback';
            }
        }

        // --- 8. UTILITY & HELPER FUNCTIONS ---
        function getCache(key) {
            const item = localStorage.getItem(key); if (!item) return null;
            try {
                const { data, timestamp, duration } = JSON.parse(item);
                if (Date.now() - timestamp > duration) { localStorage.removeItem(key); return null; }
                return data;
            } catch (e) { localStorage.removeItem(key); return null; }
        }
        function setCache(key, data, duration) {
            const item = { data, timestamp: Date.now(), duration };
            localStorage.setItem(key, JSON.stringify(item));
        }
        function showError(message) { dom.loading.innerHTML = `<div class="alert alert-danger" role="alert">${message}</div>`; }
        function getWeatherIconFromCode(code, hour) {
            // Determine if it's night time (6 PM to 6 AM)
            const isNight = hour >= 18 || hour < 6;
            
            // Return colorful weather emojis based on Open-Meteo weather codes
            if (isNight) {
                const nightMap = {
                    0: '🌙',      // Clear night
                    1: '🌙',      // Mainly clear night
                    2: '☁️',     // Partly cloudy night
                    3: '☁️',     // Overcast night
                    45: '🌫️',    // Foggy
                    48: '🌫️',    // Depositing rime fog
                    51: '🌧️',    // Light drizzle at night
                    53: '🌧️',    // Moderate drizzle at night
                    55: '🌧️',    // Dense drizzle at night
                    61: '🌧️',    // Slight rain at night
                    63: '🌧️',    // Moderate rain at night
                    65: '🌧️',    // Heavy rain at night
                    80: '🌧️',    // Slight rain showers at night
                    81: '🌧️',    // Moderate rain showers at night
                    82: '⛈️',     // Violent rain showers at night
                    95: '⛈️',     // Thunderstorm at night
                    96: '⛈️',     // Thunderstorm with slight hail at night
                    99: '⛈️'      // Thunderstorm with heavy hail at night
                };
                return nightMap[code] || '🌙';
            }
            
            // Day time emojis
            const dayMap = {
                0: '☀️',      // Clear sky
                1: '🌤️',     // Mainly clear
                2: '⛅',     // Partly cloudy
                3: '☁️',     // Overcast
                45: '🌫️',    // Foggy
                48: '🌫️',    // Depositing rime fog
                51: '🌦️',    // Light drizzle
                53: '🌦️',    // Moderate drizzle
                55: '🌧️',    // Dense drizzle
                61: '🌧️',    // Slight rain
                63: '🌧️',    // Moderate rain
                65: '🌧️',    // Heavy rain
                80: '🌦️',    // Slight rain showers
                81: '🌧️',    // Moderate rain showers
                82: '⛈️',     // Violent rain showers
                95: '⛈️',     // Thunderstorm
                96: '⛈️',     // Thunderstorm with slight hail
                99: '⛈️'      // Thunderstorm with heavy hail
            };
            return dayMap[code] || '☀️';
        }
    })();
    </script>
</body>
</html>
